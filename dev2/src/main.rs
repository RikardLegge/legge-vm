#![feature(associated_type_defaults)]

mod ast;
mod macros;

use crate::ast::{Ast, AstNodeRef, NodeID};

// Define Ast structure and generate conversion impls
build_ast! {
    Storage = Storage,
    Variants = Variants,
    Empty = Empty,
    Root [
        Expression [
            Value(ValueData),
            Call(CallData)
        ]
    ]
}

// Should be generated by macro
macro_rules! reifi {
    ($node:ident $($rest:tt)*) => {
        let node_ref = $node.get_ref();
        match $node.variant() {
            Variants::Root(_) => {
                #[allow(clippy::useless_transmute)]
                let $node: AstNodeRef<Root> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }
            Variants::Expression(_) => {
                let $node: AstNodeRef<Expression> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }
            Variants::Value(_) => {
                let $node: AstNodeRef<Value> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }
            Variants::Call(_) => {
                let $node: AstNodeRef<Call> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }
        }
    };
}

// Should be generated by macro
#[derive(Debug)]
enum Variants {
    Root(Root),
    Expression(Expression),
    Value(Value),
    Call(Call),
}

// Example of dynamically adding methods to the AST, which respect the node types
trait Types {
    fn get_type(&self, ast: &Ast<Root>);
}

trait AstTypes {
    fn get_type(&self, node: impl Into<NodeID<Root>>);
}

impl AstTypes for Ast<Root> {
    fn get_type(&self, node_id: impl Into<NodeID<Root>>) {
        let node = self.get_ref(node_id.into());
        reifi! {node.get_type(self)};
    }
}

// This is how the node data is stored internally.
enum Storage {
    Empty(Empty),
    ValueData(ValueData),
    CallData(CallData),
}

// Currently no nodes need to store any data
struct Empty();

struct ValueData();

struct CallData();

fn main() {
    let mut ast = Ast::<Root>::new();
    let id = ast.node(None, |_| ValueData());
    // Ensure that dynamic dispatching works
    let id: NodeID<Root> = id.into();
    ast.get_type(id);
}

impl Types for AstNodeRef<Root> {
    fn get_type(&self, _ast: &Ast<Root>) {
        println!("Root")
    }
}

impl Types for AstNodeRef<Expression> {
    fn get_type(&self, _ast: &Ast<Root>) {
        println!("Expression")
    }
}

impl Types for AstNodeRef<Value> {
    fn get_type(&self, _ast: &Ast<Root>) {
        println!("Value")
    }
}

impl Types for AstNodeRef<Call> {
    fn get_type(&self, _ast: &Ast<Root>) {
        println!("Call")
    }
}
