mod expression;
mod statement;
mod variable;

pub use crate::node::variable::*;

use crate::node::expression::{BlockStorage, FunctionDeclarationStorage, LoopStorage};
use crate::node::statement::{
    BreakStorage, ReturnStorage, TypeDeclarationStorage, VariableDeclarationStorage,
};
use crate::types::{NodeType, NodeUsage, Types};
use crate::{ast, build_ast};
use std::borrow::Cow;

pub type Ast = ast::Ast<Any>;
pub type NodeID<T = Any> = ast::NodeID<T>;
pub type Result<T, E = Error> = std::result::Result<T, E>;

pub enum Error {}

// Define Ast structure and generate conversion impls
build_ast! {
    Storage = Storage,
    Any [
        Variable(VariableStorage),
        Expression [
            Block(BlockStorage),
            Loop(LoopStorage),
            FunctionDeclaration(FunctionDeclarationStorage)
        ],
        Statement [
            VariableDeclaration(VariableDeclarationStorage),
            TypeDeclaration(TypeDeclarationStorage),
            Return(ReturnStorage),
            Break(BreakStorage)
        ]
    ]
}

// This is how the node data is stored internally.
// Should be generated by macro
pub enum Storage {
    Any(()),

    Expression(()),
    Block(BlockStorage),
    Loop(LoopStorage),
    FunctionDeclaration(FunctionDeclarationStorage),

    Statement(()),
    VariableDeclaration(VariableDeclarationStorage),
    TypeDeclaration(TypeDeclarationStorage),
    Return(ReturnStorage),
    Break(BreakStorage),

    Variable(VariableStorage),
}

#[macro_export]
macro_rules! reified {
    ($node:ident $($rest:tt)*) => {
        use $crate::node::Storage;
        // Should be generated by macro
        $crate::reified! {@matches $node
            Any |
            Expression |
                Block | FunctionDeclaration | Loop |
            Statement |
                VariableDeclaration | TypeDeclaration |
                Return | Break |
            Variable
                => { $node $($rest)* }
        }
    };
    (@matches $node:ident $($variant:ident)|* $(|)? => $body:tt ) => {
        match $node.storage() {
            $(Storage::$variant(_) => {
                let node_ref = $node.get_ref();
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                #[allow(clippy::useless_transmute)]
                let node: $crate::ast::AstNodeRef<$crate::node::$variant> = unsafe { std::mem::transmute(node_ref) };
                $crate::reified! { @body node $body }
            }),*
        }
    };
    (@body $node:ident {$ignore:ident$($rest:tt)*} ) => {
            $node$($rest)*
    };
}

impl Types for ast::AstNodeRef<Any> {
    fn get_type<'this, 'ast>(
        &'this self,
        ast: &'ast Ast,
        usage: NodeUsage,
    ) -> Result<Cow<'ast, NodeType>> {
        let node = ast.get(self.id);
        reified! {node.get_type(ast, usage)}
    }
}
