mod expression;
mod statement;

pub use crate::node::expression::{CallData, ValueData};
use crate::{ast, build_ast};

pub type Ast = ast::Ast<Root>;
pub type NodeID<T = Root> = ast::NodeID<T>;

// Define Ast structure and generate conversion impls
build_ast! {
    Storage = Storage,
    Variants = Variants,
    Empty = Empty,
    Root [
        Expression [
            Value(ValueData),
            Call(CallData)
        ]
    ]
}

// Should be generated by macro
macro_rules! reifi {
    ($node:ident $($rest:tt)*) => {
        use $crate::node::Variants;
        let node_ref = $node.get_ref();
        match $node.variant() {
            Variants::Root(_) => {
                #[allow(clippy::useless_transmute)]
                let $node: $crate::ast::AstNodeRef<$crate::node::Root> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }
            Variants::Expression(_) => {
                let $node: $crate::ast::AstNodeRef<$crate::node::Expression> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }
            Variants::Value(_) => {
                let $node: $crate::ast::AstNodeRef<$crate::node::Value> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }
            Variants::Call(_) => {
                let $node: $crate::ast::AstNodeRef<$crate::node::Call> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }
        }
    };
}

// Should be generated by macro
#[derive(Debug)]
pub enum Variants {
    Root(Root),
    Expression(Expression),
    Value(Value),
    Call(Call),
}

// Example of dynamically adding methods to the AST, which respect the node types
pub trait Types {
    fn get_type(&self, ast: &Ast);
}

pub trait AstTypes {
    fn get_type(&self, node: impl Into<NodeID>);
}

impl AstTypes for Ast {
    fn get_type(&self, node_id: impl Into<NodeID>) {
        let node = self.get_ref(node_id.into());
        reifi! {node.get_type(self)};
    }
}

// This is how the node data is stored internally.
pub enum Storage {
    Empty(Empty),
    ValueData(ValueData),
    CallData(CallData),
}

impl Types for ast::AstNodeRef<Root> {
    fn get_type(&self, _ast: &Ast) {
        println!("Root")
    }
}

pub struct Empty();
