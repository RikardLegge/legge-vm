mod expression;
mod statement;

pub use crate::node::expression::{CallStorage, ValueStorage};
use crate::types::Types;
use crate::{ast, build_ast};

pub type Ast = ast::Ast<Any>;
pub type NodeID<T = Any> = ast::NodeID<T>;

// Define Ast structure and generate conversion impls
build_ast! {
    Storage = Storage,
    Any [
        Expression [
            Value(ValueStorage),
            Call(CallStorage)
        ],
        Statement []
    ]
}

// This is how the node data is stored internally.
// Should be generated by macro
pub enum Storage {
    Any(()),
    Expression(()),
    Value(ValueStorage),
    Call(CallStorage),

    Statement(()),
}

// Should be generated by macro
#[macro_export]
macro_rules! reified {
    ($node:ident $($rest:tt)*) => {
        use $crate::node::Storage;
        let node_ref = $node.get_ref();
        match $node.storage() {
            Storage::Any(_) => {
                #[allow(clippy::useless_transmute)]
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                let $node: $crate::ast::AstNodeRef<$crate::node::Any> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }

            Storage::Expression(_) => {
                #[allow(clippy::useless_transmute)]
                let $node: $crate::ast::AstNodeRef<$crate::node::Expression> = unsafe { std::mem::transmute(node_ref) };
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                $node$($rest)*
            }
            Storage::Value(_) => {
                #[allow(clippy::useless_transmute)]
                let $node: $crate::ast::AstNodeRef<$crate::node::Value> = unsafe { std::mem::transmute(node_ref) };
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                $node$($rest)*
            }
            Storage::Call(_) => {
                #[allow(clippy::useless_transmute)]
                let $node: $crate::ast::AstNodeRef<$crate::node::Call> = unsafe { std::mem::transmute(node_ref) };
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                $node$($rest)*
            }

            Storage::Statement(_) => {
                #[allow(clippy::useless_transmute)]
                let $node: $crate::ast::AstNodeRef<$crate::node::Statement> = unsafe { std::mem::transmute(node_ref) };
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                $node$($rest)*
            }
        }
    };
}

impl Types<Any> for ast::AstNodeRef<Any> {
    fn get_type(&self, ast: &Ast) {
        let node = ast.get(self.id);
        reified! {node.get_type(ast)};
    }
}
