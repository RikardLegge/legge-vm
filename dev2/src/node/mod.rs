mod expression;
mod statement;

pub use crate::node::expression::{CallStorage, ValueStorage};
use crate::node::plugins::Types;
use crate::{ast, build_ast};

pub type Ast = ast::Ast<Any>;
pub type NodeID<T = Any> = ast::NodeID<T>;

// Define Ast structure and generate conversion impls
build_ast! {
    Storage = Storage,
    Any [
        Expression [
            Value(ValueStorage),
            Call(CallStorage)
        ],
        Statement []
    ]
}

// This is how the node data is stored internally.
// Should be generated by macro
pub enum Storage {
    Any,
    Expression,
    Value(ValueStorage),
    Call(CallStorage),

    Statement,
}

// Should be generated by macro
#[macro_export]
macro_rules! reified {
    ($node:ident $($rest:tt)*) => {
        use $crate::node::Storage;
        let node_ref = $node.get_ref();
        match $node.storage() {
            Storage::Any => {
                #[allow(clippy::useless_transmute)]
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                let $node: $crate::ast::AstNodeRef<$crate::node::Any> = unsafe { std::mem::transmute(node_ref) };
                $node$($rest)*
            }

            Storage::Expression => {
                #[allow(clippy::useless_transmute)]
                let $node: $crate::ast::AstNodeRef<$crate::node::Expression> = unsafe { std::mem::transmute(node_ref) };
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                $node$($rest)*
            }
            Storage::Value(_) => {
                #[allow(clippy::useless_transmute)]
                let $node: $crate::ast::AstNodeRef<$crate::node::Value> = unsafe { std::mem::transmute(node_ref) };
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                $node$($rest)*
            }
            Storage::Call(_) => {
                #[allow(clippy::useless_transmute)]
                let $node: $crate::ast::AstNodeRef<$crate::node::Call> = unsafe { std::mem::transmute(node_ref) };
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                $node$($rest)*
            }

            Storage::Statement => {
                #[allow(clippy::useless_transmute)]
                let $node: $crate::ast::AstNodeRef<$crate::node::Statement> = unsafe { std::mem::transmute(node_ref) };
                // Safety: Only affects the marker types on AstNodeRef. The marker
                // traits are never trusted and real conversion checks are always
                // executed when extracting data.
                $node$($rest)*
            }
        }
    };
}

impl Types for ast::AstNodeRef<Any> {
    fn get_type(&self, ast: &Ast) {
        let node = ast.get(self.id);
        reified! {node.get_type(ast)};
    }
}

pub mod plugins {
    use super::Ast;
    use crate::ast::{AstNode, AstNodeRef, NodeBody};

    // Example of dynamically adding methods to the AST, which respect the node types
    pub trait Types {
        fn get_type(&self, ast: &Ast);
    }

    impl<Any: NodeBody> Types for AstNode<Any>
    where
        AstNodeRef<Any>: Types,
    {
        fn get_type(&self, ast: &Ast) {
            self.get_ref().get_type(ast)
        }
    }
}
